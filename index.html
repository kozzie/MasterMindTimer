<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Mastermind Timer</title>
    <style>
        /* All previous CSS remains the same */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-image: url('BrotherHoodOfFire.jpeg'); background-size: cover; background-position: center 30%; background-repeat: no-repeat; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #000; background-attachment: fixed; padding: 15px; }
        .container { display: flex; gap: 40px; background-color: rgba(0, 0, 0, 0.85); padding: 30px; border-radius: 15px; box-shadow: 0 0 25px rgba(255, 165, 0, 0.5); width: 100%; max-width: 1000px; border: 1px solid rgba(255, 165, 0, 0.3); transition: all 0.3s ease; }
        .timer-panel { flex: 1; text-align: center; }
        .agenda-panel { flex: 1; border-left: 1px solid #ff8c00; padding-left: 40px; }
        #currentSectionTitle { font-size: 2rem; margin-bottom: 5px; min-height: 70px; }
        #currentSubSectionTitle { font-size: 1.5rem; color: #ddd; min-height: 30px; font-weight: bold; }
        #timer { font-size: 6rem; font-weight: bold; margin: 20px 0; transition: color 0.5s ease; }
        #timer.warning { color: #f39c12; }
        #timer.danger { color: #e74c3c; }
        .buttons { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; }
        .buttons button { background-color: #ff8c00; color: white; border: none; padding: 10px 20px; font-size: 1rem; margin: 5px 4px; cursor: pointer; border-radius: 8px; transition: background-color 0.3s ease; display: inline-flex; align-items: center; justify-content: center; }
        .buttons button.icon-btn { padding: 10px; width: 40px; height: 40px; }
        .buttons button.icon-btn svg { width: 20px; height: 20px; }
        .buttons button:disabled { background-color: #555; cursor: not-allowed; opacity: 0.6; }
        .buttons button:not(:disabled):hover { background-color: #ffa500; }
        #agendaList { padding-top: 15px; list-style: none; }
        #agendaList li { padding: 8px; border-radius: 5px; margin-bottom: 5px; transition: background-color 0.3s ease; }
        #agendaList .current-section { background-color: rgba(255, 140, 0, 0.3); font-weight: bold; }
        .time-display { float: right; }
        .original-time { color: #aaa; text-decoration: line-through; margin-right: 10px; font-size: 0.9em; }

        /* --- NEW STYLES FOR CUSTOM DURATION INPUT --- */
        .duration-control {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 140, 0, 0.2);
        }
        .duration-control label {
            margin-right: 10px;
            font-size: 1.1rem; /* Corrected typo here */
        }
        .duration-control input {
            width: 80px;
            padding: 8px;
            background-color: #333;
            border: 1px solid #ff8c00;
            color: #fff;
            border-radius: 5px;
            font-size: 1.1rem;
        }
        h1, h2 { color: #ff8c00; text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7); }
        @media (max-width: 768px) {
            body { align-items: flex-start; }
            .container { flex-direction: column; gap: 25px; }
            .agenda-panel { border-left: none; border-top: 1px solid #ff8c00; padding-left: 0; padding-top: 25px; }
            #timer { font-size: 4.5rem; }
            #currentSectionTitle { font-size: 1.6rem; min-height: auto; }
            #currentSubSectionTitle { font-size: 1.2rem; }
            .buttons button { padding: 12px 20px; font-size: 1rem; }
            #agendaList { font-size: 1rem; }
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="timer-panel">
            <h1 id="currentSectionTitle">Session Not Started</h1>
            <h3 id="currentSubSectionTitle"></h3>
            <div id="timer">00:00</div>
            <div class="buttons">  
                <button id="startBtn" disabled>Start Session</button>
                <button id="pauseBtn" disabled>Pause</button>
                <button id="nextBtn" disabled>Next</button>
                <button id="testSoundBtn" class="icon-btn" disabled aria-label="Test Sound">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
                </button> 
            </div>
        </div>
        <div class="agenda-panel">
            <h2>Agenda</h2>
            <!-- NEW: Custom duration control -->
            <div class="duration-control">
                <label for="totalDurationInput">Total Time (min):</label>
                <input type="number" id="totalDurationInput" min="1">
                <span id="originalDurationDisplay"></span>
            </div>
            <ul id="agendaList"></ul>
        </div>
    </div>

    <audio id="beep-sound" preload="auto" style="display: none;" src="beep.mp3"></audio>

    <script>
        const sessionTemplate = [
            { name: "Housekeeping/Arrival", duration: 10 * 60, subSections: 1 },
            { name: "Focus Member", duration: 25 * 60, subSections: 1 }, // 25 min
            { name: "Goal Debrief & Catchup", duration: 25 * 60, subSections: 2, subSectionLabels: ["Non-Focus Member 1", "Non-Focus Member 2"] }, // Was 20, now 25
            { name: "Upcoming Goals", duration: 10 * 60, subSections: 3 }, // Was 15, now 10
            { name: "Gratitudes & Affirmations", duration: 15 * 60, subSections: 3 }
        ];

        let sessionPlan = [];
        let currentSectionIndex = -1;
        let currentSubSectionIndex = 0;
        let timeLeftInSection = 0;
        let isPaused = false;
        let timerInterval = null;
        let originalTotalDuration = 0; // NEW: To store the original total

        const timerEl = document.getElementById('timer');
        const agendaListEl = document.getElementById('agendaList');
        const sectionTitleEl = document.getElementById('currentSectionTitle');
        const subSectionTitleEl = document.getElementById('currentSubSectionTitle');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const nextBtn = document.getElementById('nextBtn');
        const testSoundBtn = document.getElementById('testSoundBtn');
        const beepSoundElement = document.getElementById('beep-sound');
        const totalDurationInput = document.getElementById('totalDurationInput'); // NEW
        const originalDurationDisplay = document.getElementById('originalDurationDisplay'); // NEW

        let audioContext;
        let audioBuffer;

        function initAudio() {
            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
            } catch (e) { console.error("Web Audio API is not supported in this browser"); sectionTitleEl.textContent = "Sound not supported."; return; }
            sectionTitleEl.textContent = "Loading sound...";
            fetch(beepSoundElement.src)
                .then(response => { if (!response.ok) { throw new Error(`File not found: ${response.statusText}`); } return response.arrayBuffer(); })
                .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                .then(decodedBuffer => {
                    audioBuffer = decodedBuffer; 
                    console.log("Audio file loaded successfully.");
                    sectionTitleEl.textContent = "Session Not Started";
                    startBtn.disabled = false;
                    testSoundBtn.disabled = false;
                    totalDurationInput.disabled = false;

                    // Initial calculation after sound loads
                    recalculateAndDistributeTimings();

                    // Now that timings are calculated, set the initial display
                    const firstSectionTime = sessionPlan[0].subSectionDurations[0];
                    timerEl.textContent = formatTime(firstSectionTime);

                })
                .catch(error => { console.error("Failed to load audio file:", error); sectionTitleEl.textContent = "Error loading sound."; subSectionTitleEl.innerHTML = "Use VS Code 'Live Server' to run."; });
        }

        function unlockAudioContext() { if (audioContext && audioContext.state === 'suspended') { audioContext.resume(); console.log("AudioContext resumed!"); } }
        function playBeep() { if (!audioContext || !audioBuffer) return; const source = audioContext.createBufferSource(); source.buffer = audioBuffer; source.connect(audioContext.destination); source.start(0); }
        function playDoubleBeep() { playBeep(); setTimeout(playBeep, 200); }

        function formatTime(seconds) {
            const roundedSeconds = Math.round(seconds);
            const mins = Math.floor(roundedSeconds / 60).toString().padStart(2, '0');
            const secs = (roundedSeconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        }

        function recalculateAndDistributeTimings() {
            const newTotalMinutes = parseFloat(totalDurationInput.value);
            if (isNaN(newTotalMinutes) || newTotalMinutes <= 0) {
                alert("Invalid total time. Please enter a positive number.");
                totalDurationInput.value = Math.round(sessionPlan.reduce((total, sec) => total + sec.adjustedDuration, 0) / 60);
                return;
            }
            const newTotalSeconds = newTotalMinutes * 60;

            if (currentSectionIndex === -1) {
                // Session hasn't started, scale all sub-sections proportionally
                const scalingFactor = newTotalSeconds / originalTotalDuration;
                sessionPlan.forEach(section => {
                    for (let i = 0; i < section.subSectionDurations.length; i++) {
                        // Scale based on the original template duration
                        const originalSubSectionDuration = section.duration / section.subSections;
                        section.subSectionDurations[i] = originalSubSectionDuration * scalingFactor;
                    }
                });
            } else {
                // Session is in progress, redistribute remaining time over future sub-sections
                let timeAlreadyPassed = 0;
                // Add up actual time for completed sections
                for (let i = 0; i < currentSectionIndex; i++) {
                    const actualsSum = sessionPlan[i].actualSubSectionDurations.reduce((a, b) => a + (b || 0), 0);
                    timeAlreadyPassed += actualsSum;
                }
                
                // Add up actual time for completed sub-sections in the current section
                const currentSection = sessionPlan[currentSectionIndex];
                for (let i = 0; i < currentSubSectionIndex - 1; i++) {
                    timeAlreadyPassed += currentSection.actualSubSectionDurations[i] || 0;
                }

                // Add time passed in the currently running sub-section
                const plannedTimeForCurrentSub = currentSection.subSectionDurations[currentSubSectionIndex - 1];
                const timePassedInCurrentSub = (plannedTimeForCurrentSub - timeLeftInSection);
                timeAlreadyPassed += timePassedInCurrentSub;

                // Now, find all future sub-sections (including the current one)
                let futureSubSections = [];
                // Remaining in current section (from current sub-section onwards)
                for (let i = currentSubSectionIndex - 1; i < currentSection.subSections; i++) {
                    futureSubSections.push({ section: currentSectionIndex, subSection: i });
                }
                // All sub-sections in future sections
                for (let i = currentSectionIndex + 1; i < sessionPlan.length; i++) {
                    for (let j = 0; j < sessionPlan[i].subSections; j++) {
                        futureSubSections.push({ section: i, subSection: j });
                    }
                }

                const totalRemainingTimeToDistribute = newTotalSeconds - timeAlreadyPassed;
                
                if (futureSubSections.length > 0 && totalRemainingTimeToDistribute > 0) {
                    const newPerSubSectionTime = totalRemainingTimeToDistribute / futureSubSections.length;
                    
                    futureSubSections.forEach(item => {
                        sessionPlan[item.section].subSectionDurations[item.subSection] = newPerSubSectionTime;
                    });

                    // Important: Update the current timeLeftInSection with the new value
                    timeLeftInSection = newPerSubSectionTime - timePassedInCurrentSub;
                    if (!isPaused) {
                        updateTimer(); // Refresh display
                    }
                }
            }

            renderAgenda();
        }


        function initializeSession() {
            // Calculate original total duration once
            originalTotalDuration = sessionTemplate.reduce((total, section) => total + section.duration, 0);

            // Create a mutable copy of the session template for manipulation
            sessionPlan = sessionTemplate.map(s => {
                const subSectionDuration = s.duration / s.subSections;
                const subSectionDurations = Array(s.subSections).fill(subSectionDuration);
                return {
                    ...s,
                    adjustedDuration: s.duration,
                    subSectionDurations: subSectionDurations,
                    actualSubSectionDurations: Array(s.subSections).fill(null)
                };
            });
            
            // Set up the new duration input
            const originalTotalMinutes = Math.round(originalTotalDuration / 60);
            totalDurationInput.value = originalTotalMinutes;
            totalDurationInput.disabled = true; // Disabled until sound loads
            
            renderAgenda(); 
            initAudio(); 
        }

        function renderAgenda() {
            agendaListEl.innerHTML = '';
            sessionPlan.forEach((section, index) => {
                // First, ensure the section's total duration is up-to-date
                section.adjustedDuration = section.subSectionDurations.reduce((a, b) => a + b, 0);

                const li = document.createElement('li');
                if (index === currentSectionIndex) { li.className = 'current-section'; }
                let timeHtml = `<span class="adjusted-time">${formatTime(section.adjustedDuration || 0)}</span>`;
                if (Math.round(section.adjustedDuration) !== section.duration) {
                    timeHtml = `<span class="original-time">${formatTime(section.duration)}</span>` + timeHtml;
                }
                li.innerHTML = `${section.name} <span class="time-display">${timeHtml}</span>`;
                agendaListEl.appendChild(li);
            });
        }

        function startSession() {
            totalDurationInput.disabled = false; // Allow changes mid-session
            currentSectionIndex = 0;
            currentSubSectionIndex = 1;
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            nextBtn.disabled = false;
            startCurrentSection();
        }

        function startCurrentSection() {
            isPaused = false;
            pauseBtn.textContent = 'Pause';
            const section = sessionPlan[currentSectionIndex];

            // Correctly get the duration for the specific sub-section
            timeLeftInSection = section.subSectionDurations[currentSubSectionIndex - 1];

            sectionTitleEl.textContent = section.name;
            if (section.subSectionLabels) { subSectionTitleEl.textContent = section.subSectionLabels[currentSubSectionIndex - 1]; } 
            else if (section.subSections > 1) { subSectionTitleEl.textContent = `Member ${currentSubSectionIndex} of ${section.subSections}`; } 
            else { subSectionTitleEl.textContent = ''; }
            
            renderAgenda(); 
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            updateTimer(); // Call once to display time immediately
        }

        function updateTimer() {
            if (isPaused) return;
            timerEl.textContent = formatTime(timeLeftInSection);
            if (timeLeftInSection <= 10) timerEl.classList.add('danger');
            else if (timeLeftInSection <= 30) timerEl.classList.add('warning');
            else timerEl.classList.remove('warning', 'danger');
            if (timeLeftInSection <= 0) { moveToNext(); } 
            else { timeLeftInSection--; }
        }
        
        function pauseResumeTimer() { isPaused = !isPaused; pauseBtn.textContent = isPaused ? 'Resume' : 'Pause'; }

        function moveToNext(isManualSkip = false) {
            clearInterval(timerInterval);
            timerEl.classList.remove('warning', 'danger');

            const section = sessionPlan[currentSectionIndex];
            const subSectionIndex = currentSubSectionIndex - 1;

            // 1. Record the actual time spent
            const plannedDuration = section.subSectionDurations[subSectionIndex];
            const actualTimeSpent = plannedDuration - timeLeftInSection;
            section.actualSubSectionDurations[subSectionIndex] = actualTimeSpent;

            // 2. If it was a manual skip, redistribute the saved time
            if (isManualSkip && timeLeftInSection > 0) {
                // THE FIX: First, update the skipped item's own duration to what was actually spent.
                section.subSectionDurations[subSectionIndex] = actualTimeSpent;
                // Now, redistribute the time that was saved.
                adjustFutureTimings(timeLeftInSection);
            }

            // 3. Move to the next section/sub-section
            if (currentSubSectionIndex >= section.subSections) {
                // Only beep when transitioning automatically between major sections
                if (!isManualSkip && currentSectionIndex < sessionPlan.length - 1) {
                    playDoubleBeep();
                }
                currentSectionIndex++;
                currentSubSectionIndex = 1;
            } else {
                currentSubSectionIndex++;
            }

            if (currentSectionIndex >= sessionPlan.length) {
                endSession();
                return;
            }
            
            startCurrentSection();
        }

        function adjustFutureTimings(savedTime) {
            if (savedTime <= 0) return;

            // 1. Collect all future sub-section indices
            let futureSubSections = [];
            // Sub-sections remaining in the current section (the one we are about to start)
            for (let i = currentSubSectionIndex; i < sessionPlan[currentSectionIndex].subSections; i++) {
                futureSubSections.push({ section: currentSectionIndex, subSection: i });
            }
            // Sub-sections in all future sections
            for (let i = currentSectionIndex + 1; i < sessionPlan.length; i++) {
                for (let j = 0; j < sessionPlan[i].subSections; j++) {
                    futureSubSections.push({ section: i, subSection: j });
                }
            }

            // 2. If there are future sub-sections, distribute the saved time
            if (futureSubSections.length > 0) {
                const timeToAdd = savedTime / futureSubSections.length;
                futureSubSections.forEach(item => {
                    sessionPlan[item.section].subSectionDurations[item.subSection] += timeToAdd;
                });
            }

            // 3. Re-render the agenda to show the new times
            renderAgenda();
        }

        function endSession() {
            sectionTitleEl.textContent = "Session Complete!";
            subSectionTitleEl.textContent = "";
            timerEl.textContent = "Done";
            pauseBtn.disabled = true;
            nextBtn.disabled = true;
            testSoundBtn.disabled = false;
            totalDurationInput.disabled = false;
        }

        
        // --- Setup Event Listeners ---
        startBtn.addEventListener('click', startSession);
        pauseBtn.addEventListener('click', pauseResumeTimer);
        nextBtn.addEventListener('click', () => moveToNext(true));
        testSoundBtn.addEventListener('click', playDoubleBeep);
        totalDurationInput.addEventListener('input', recalculateAndDistributeTimings);

        document.querySelectorAll('.buttons button').forEach(button  => {
            button.addEventListener('click', unlockAudioContext, { once: true });
        });

        document.addEventListener('DOMContentLoaded', initializeSession);
    </script>
</body>
</html>

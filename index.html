<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Mastermind Timer</title>
    <style>
        /* All previous CSS remains the same */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-image: url('BrotherHoodOfFire.jpeg'); background-size: cover; background-position: center 30%; background-repeat: no-repeat; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #000; background-attachment: fixed; padding: 15px; }
        .container { display: flex; gap: 40px; background-color: rgba(0, 0, 0, 0.85); padding: 30px; border-radius: 15px; box-shadow: 0 0 25px rgba(255, 165, 0, 0.5); width: 100%; max-width: 1000px; border: 1px solid rgba(255, 165, 0, 0.3); transition: all 0.3s ease; }
        .timer-panel { flex: 1; text-align: center; }
        .agenda-panel { flex: 1; border-left: 1px solid #ff8c00; padding-left: 40px; }
        #currentSectionTitle { font-size: 2rem; margin-bottom: 5px; min-height: 70px; }
        #currentSubSectionTitle { font-size: 1.5rem; color: #ddd; min-height: 30px; font-weight: bold; }
        #timer { font-size: 6rem; font-weight: bold; margin: 20px 0; transition: color 0.5s ease; }
        #timer.warning { color: #f39c12; }
        #timer.danger { color: #e74c3c; }
        .buttons { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; }
        .buttons button { background-color: #ff8c00; color: white; border: none; padding: 10px 20px; font-size: 1rem; margin: 5px 4px; cursor: pointer; border-radius: 8px; transition: background-color 0.3s ease; display: inline-flex; align-items: center; justify-content: center; }
        .buttons button.icon-btn { padding: 10px; width: 40px; height: 40px; }
        .buttons button.icon-btn svg { width: 20px; height: 20px; }
        .buttons button:disabled { background-color: #555; cursor: not-allowed; opacity: 0.6; }
        .buttons button:not(:disabled):hover { background-color: #ffa500; }
        #agendaList { padding-top: 15px; list-style: none; }
        #agendaList li { padding: 8px; border-radius: 5px; margin-bottom: 5px; transition: background-color 0.3s ease; }
        #agendaList .current-section { background-color: rgba(255, 140, 0, 0.3); font-weight: bold; }
        .time-display { float: right; }
        .original-time { color: #aaa; text-decoration: line-through; margin-right: 10px; font-size: 0.9em; }

        /* --- NEW STYLES FOR CUSTOM DURATION INPUT --- */
        .duration-control {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 140, 0, 0.2);
        }
        .duration-control label {
            margin-right: 10px;
            font-size: 1.1rem; /* Corrected typo here */
        }
        .duration-control input {
            width: 80px;
            padding: 8px;
            background-color: #333;
            border: 1px solid #ff8c00;
            color: #fff;
            border-radius: 5px;
            font-size: 1.1rem;
        }
        h1, h2 { color: #ff8c00; text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7); }
        @media (max-width: 768px) {
            body { align-items: flex-start; }
            .container { flex-direction: column; gap: 25px; }
            .agenda-panel { border-left: none; border-top: 1px solid #ff8c00; padding-left: 0; padding-top: 25px; }
            #timer { font-size: 4.5rem; }
            #currentSectionTitle { font-size: 1.6rem; min-height: auto; }
            #currentSubSectionTitle { font-size: 1.2rem; }
            .buttons button { padding: 12px 20px; font-size: 1rem; }
            #agendaList { font-size: 1rem; }
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="timer-panel">
            <h1 id="currentSectionTitle">Session Not Started</h1>
            <h3 id="currentSubSectionTitle"></h3>
            <div id="timer">00:00</div>
            <div class="buttons">  
                <button id="startBtn" disabled>Start Session</button>
                <button id="pauseBtn" disabled>Pause</button>
                <button id="nextBtn" disabled>Next</button>
                <button id="testSoundBtn" class="icon-btn" disabled aria-label="Test Sound">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
                </button> 
            </div>
        </div>
        <div class="agenda-panel">
            <h2>Agenda</h2>
            <!-- NEW: Custom duration control -->
            <div class="duration-control">
                <label for="totalDurationInput">Total Time (min):</label>
                <input type="number" id="totalDurationInput" min="1">
                <span id="originalDurationDisplay"></span>
            </div>
            <ul id="agendaList"></ul>
        </div>
    </div>

    <audio id="beep-sound" preload="auto" style="display: none;" src="beep.mp3"></audio>

    <script>
        const sessionTemplate = [
            { name: "Housekeeping/Arrival", duration: 10 * 60, subSections: 1 },
            { name: "Focus Member (Goal Debrief & Catchup)", duration: 25 * 60, subSections: 1 }, // 25 min
            { name: "Goal Debrief & Catchup", duration: 25 * 60, subSections: 2, subSectionLabels: ["Non-Focus Member 1", "Non-Focus Member 2"] }, // Was 20, now 25
            { name: "Upcoming Goals (All)", duration: 10 * 60, subSections: 3 }, // Was 15, now 10
            { name: "Gratitudes & Affirmations", duration: 15 * 60, subSections: 3 }
        ];

        let sessionPlan = [];
        let currentSectionIndex = -1;
        let currentSubSectionIndex = 0;
        let timeLeftInSection = 0;
        let isPaused = false;
        let timerInterval = null;
        let originalTotalDuration = 0; // NEW: To store the original total

        const timerEl = document.getElementById('timer');
        const agendaListEl = document.getElementById('agendaList');
        const sectionTitleEl = document.getElementById('currentSectionTitle');
        const subSectionTitleEl = document.getElementById('currentSubSectionTitle');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const nextBtn = document.getElementById('nextBtn');
        const testSoundBtn = document.getElementById('testSoundBtn');
        const beepSoundElement = document.getElementById('beep-sound');
        const totalDurationInput = document.getElementById('totalDurationInput'); // NEW
        const originalDurationDisplay = document.getElementById('originalDurationDisplay'); // NEW

        let audioContext;
        let audioBuffer;

        function initAudio() {
            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
            } catch (e) { console.error("Web Audio API is not supported in this browser"); sectionTitleEl.textContent = "Sound not supported."; return; }
            sectionTitleEl.textContent = "Loading sound...";
            fetch(beepSoundElement.src)
                .then(response => { if (!response.ok) { throw new Error(`File not found: ${response.statusText}`); } return response.arrayBuffer(); })
                .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                .then(decodedBuffer => {
                    audioBuffer = decodedBuffer; 
                    console.log("Audio file loaded successfully.");
                    sectionTitleEl.textContent = "Session Not Started";
                    startBtn.disabled = false;
                    testSoundBtn.disabled = false;
                    totalDurationInput.disabled = false;

                    // Initial calculation after sound loads
                    recalculateAndDistributeTimings();

                    // Now that timings are calculated, set the initial display
                    const firstSectionTime = sessionPlan[0].adjustedDuration / sessionPlan[0].subSections;
                    timerEl.textContent = formatTime(firstSectionTime);

                })
                .catch(error => { console.error("Failed to load audio file:", error); sectionTitleEl.textContent = "Error loading sound."; subSectionTitleEl.innerHTML = "Use VS Code 'Live Server' to run."; });
        }

        function unlockAudioContext() { if (audioContext && audioContext.state === 'suspended') { audioContext.resume(); console.log("AudioContext resumed!"); } }
        function playBeep() { if (!audioContext || !audioBuffer) return; const source = audioContext.createBufferSource(); source.buffer = audioBuffer; source.connect(audioContext.destination); source.start(0); }
        function playDoubleBeep() { playBeep(); setTimeout(playBeep, 200); }

        function formatTime(seconds) {
            const roundedSeconds = Math.round(seconds);
            const mins = Math.floor(roundedSeconds / 60).toString().padStart(2, '0');
            const secs = (roundedSeconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        }

        // --- UPDATED FUNCTION to recalculate all timings, even mid-session ---
        function recalculateAndDistributeTimings() {
            const newTotalMinutes = parseFloat(totalDurationInput.value);
            let newTotalSeconds;

            if (isNaN(newTotalMinutes) || newTotalMinutes <= 0) {
                alert("Invalid total time. Reverting to original session time.");

                // If input is invalid, reset to original durations
                newTotalSeconds = originalTotalDuration;
            } else {
                newTotalSeconds = newTotalMinutes * 60;
            }

            // If session is not running, just scale everything
            if (currentSectionIndex === -1) {
                const scalingFactor = newTotalSeconds / originalTotalDuration;
                sessionPlan.forEach(section => {
                    section.adjustedDuration = section.duration * scalingFactor;
                });
            } else {
                // If session is running, redistribute remaining time
                let timeAlreadyPassed = 0;
                for (let i = 0; i < currentSectionIndex; i++) {
                    timeAlreadyPassed += sessionPlan[i].adjustedDuration;
                }

                const currentSection = sessionPlan[currentSectionIndex];
                const timePerSubSection = currentSection.adjustedDuration / currentSection.subSections;
                const timePassedInCurrentSection = (timePerSubSection * (currentSubSectionIndex - 1)) + (timePerSubSection - timeLeftInSection);
                timeAlreadyPassed += timePassedInCurrentSection;

                const totalRemainingTimeToDistribute = newTotalSeconds - timeAlreadyPassed;
                let originalTimeLeft = 0;
                for (let i = currentSectionIndex; i < sessionPlan.length; i++) {
                    originalTimeLeft += sessionPlan[i].duration;
                }
                const scalingFactor = totalRemainingTimeToDistribute / originalTimeLeft;

                for (let i = currentSectionIndex; i < sessionPlan.length; i++) {
                    sessionPlan[i].adjustedDuration = sessionPlan[i].duration * scalingFactor;
                }
            }

            renderAgenda();
        }


        function initializeSession() {
            // Calculate original total duration once
            originalTotalDuration = sessionTemplate.reduce((total, section) => total + section.duration, 0);

            // Create a mutable copy of the session template for manipulation
            sessionPlan = sessionTemplate.map(s => ({ ...s, adjustedDuration: s.duration }));
            
            // Set up the new duration input
            const originalTotalMinutes = Math.round(originalTotalDuration / 60);
            totalDurationInput.value = originalTotalMinutes;
            totalDurationInput.disabled = true; // Disabled until sound loads
            
            renderAgenda(); 
            initAudio(); 
        }

        function renderAgenda() {
            agendaListEl.innerHTML = '';
            sessionPlan.forEach((section, index) => {
                const li = document.createElement('li');
                if (index === currentSectionIndex) { li.className = 'current-section'; }
                let timeHtml = `<span class="adjusted-time">${formatTime(section.adjustedDuration || 0)}</span>`;
                if (Math.round(section.adjustedDuration) !== section.duration) {
                    timeHtml = `<span class="original-time">${formatTime(section.duration)}</span>` + timeHtml;
                }
                li.innerHTML = `${section.name} <span class="time-display">${timeHtml}</span>`;
                agendaListEl.appendChild(li);
            });
        }

        function startSession() {
            totalDurationInput.disabled = false; // Allow changes mid-session
            totalDurationInput.disabled = false;
            currentSectionIndex = 0;
            currentSubSectionIndex = 1;
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            nextBtn.disabled = false;
            startCurrentSection();
        }

        function startCurrentSection() {
            isPaused = false;
            pauseBtn.textContent = 'Pause';
            const section = sessionPlan[currentSectionIndex];
            timeLeftInSection = Math.round(section.adjustedDuration / section.subSections);
            sectionTitleEl.textContent = section.name;
            if (section.subSectionLabels) { subSectionTitleEl.textContent = section.subSectionLabels[currentSubSectionIndex - 1]; } 
            else if (section.subSections > 1) { subSectionTitleEl.textContent = `Member ${currentSubSectionIndex} of ${section.subSections}`; } 
            else { subSectionTitleEl.textContent = ''; }
            renderAgenda(); 
            timerInterval = setInterval(updateTimer, 1000);
            timeLeftInSection = Math.round(section.adjustedDuration / section.subSections); // Initialize timeLeftInSection
            updateTimer();
        }

        function updateTimer() {
            if (isPaused) return;
            timerEl.textContent = formatTime(timeLeftInSection);
            if (timeLeftInSection <= 10) timerEl.classList.add('danger');
            else if (timeLeftInSection <= 30) timerEl.classList.add('warning');
            else timerEl.classList.remove('warning', 'danger');
            if (timeLeftInSection <= 0) { moveToNext(); } 
            else { timeLeftInSection--; }
        }
        
        function pauseResumeTimer() { isPaused = !isPaused; pauseBtn.textContent = isPaused ? 'Resume' : 'Pause'; }

        function moveToNext(isManualSkip = false) {
            clearInterval(timerInterval);
            timerEl.classList.remove('warning', 'danger');
            const variance = timeLeftInSection; 
            adjustFutureTimings(variance);

            const section = sessionPlan[currentSectionIndex];

            // Check if we are at the end of a major section
            if (currentSubSectionIndex >= section.subSections) {
                // Only beep when transitioning automatically between major sections
                if (!isManualSkip && currentSectionIndex < sessionPlan.length - 1) {
                    playDoubleBeep();
                }
                currentSectionIndex++;
                currentSubSectionIndex = 1;
            } else {
                currentSubSectionIndex++;
            }

            if (currentSectionIndex >= sessionPlan.length) { endSession(); return; }
            startCurrentSection();
        }

        function adjustFutureTimings(varianceInSeconds) {
            if (varianceInSeconds === 0) return;
            let totalFutureDuration = 0;
            for (let i = currentSectionIndex; i < sessionPlan.length; i++) {
                if (i === currentSectionIndex) {
                    const remainingSubSections = sessionPlan[i].subSections - currentSubSectionIndex;
                    totalFutureDuration += (sessionPlan[i].adjustedDuration / sessionPlan[i].subSections) * remainingSubSections;
                } else {
                    totalFutureDuration += sessionPlan[i].adjustedDuration;
                }
            }
            if (totalFutureDuration <= 0) return;
            for (let i = currentSectionIndex; i < sessionPlan.length; i++) {
                let currentBlockDuration = 0;
                if (i === currentSectionIndex) {
                    const remainingSubSections = sessionPlan[i].subSections - currentSubSectionIndex;
                    currentBlockDuration = (sessionPlan[i].adjustedDuration / sessionPlan[i].subSections) * remainingSubSections;
                } else {
                    currentBlockDuration = sessionPlan[i].adjustedDuration;
                }
                const proportion = currentBlockDuration / totalFutureDuration;
                const adjustment = varianceInSeconds * proportion;
                sessionPlan[i].adjustedDuration += adjustment;
            }
        }

        function endSession() {
            sectionTitleEl.textContent = "Session Complete!";
            subSectionTitleEl.textContent = "";
            timerEl.textContent = "Done";
            pauseBtn.disabled = true;
            nextBtn.disabled = true;
            testSoundBtn.disabled = false;
            totalDurationInput.disabled = false;
        }

        
        // --- Setup Event Listeners ---
        startBtn.addEventListener('click', startSession);
        pauseBtn.addEventListener('click', pauseResumeTimer);
        nextBtn.addEventListener('click', () => moveToNext(true));
        testSoundBtn.addEventListener('click', playDoubleBeep);
        totalDurationInput.addEventListener('input', recalculateAndDistributeTimings);

        document.querySelectorAll('.buttons button').forEach(button  => {
            button.addEventListener('click', unlockAudioContext, { once: true });
        });

        document.addEventListener('DOMContentLoaded', initializeSession);
    </script>
</body>
</html>
